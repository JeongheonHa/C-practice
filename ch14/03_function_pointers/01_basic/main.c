/* 함수 포인터의 원리 */
/*
    - 함수의 주소값을 저장한다.
    - 변수에 대한 포인터에서 포인터 연산을 하기 위해 자료형의 크기를 미리 알아야 했던 것 처럼 함수의 반환 자료형과 파리미터의 자료형이 무엇인지 선언해줘야한다.
      ex) int* a에서 a++는 sizeof(int)만큼 주소값 증가
*/

#include <stdio.h>

void f1()
{
    return;
}

int f2(char i)
{
    return i + 1;
}

int main()
{
    void (*pf1)() = f1;      // &를 붙여도 되고 안붙여도 된다.
    // void (*pf1)() = &f1;  // 함수의 이름 자체가 포인터이다. (함수를 실행시킬때 그 함수의 주소에 있는 코드를 실행시킨다는 개념)
                            

    int (*pf2)(char) = f2;

    (*pf1)();   // 1. 포인터 변수의 indrection을 통해 함수의 이름을 실행, 포인터 변수를 이용해 함수 선언 (call f1 via pf1) , 
    // pf1();   // 2. 포인터 변수의 값인 함수의 주소를 실행한다는 뜻 (둘 다 같은 뜻)

    int a = pf2('A');
    // int a = (*pf2)('A');
    
    printf("%d\n", a);  // 66

    return 0;
}

/* 함수 포인터의 성질 */

/*
    1. 파일을 작성하고 컴파일하면 실행파일이 만들어지고 하드디스크에 저장
    2. 사용자가 운영체제에게 실행파일을 실행하라고 요청
    3. 운영체제가 프로그램 자체를 메모리에 복사해서 올려준다. (in TEXT Segment)
    
    - 함수가 저장되어 있는 곳은 TEXT Segment이기 때문에 낮은 주소 값이 낮다

    - 프로그래머는 함수의 이름을 이용해서 프로그램을 작성하지만 컴파일러는 이름(식별자)들을 메모리에서의 주소로 번역한다.
      즉, 함수를 실행시킨다는 것은 메모리에서 함수의 주소 위치에 저장되어 있는 명령어들을 순차적으로 수행한다는 의미
*/